## 2020: Created by Sarah E. Wright, The University of Manchester# 2023: Updated by Joanna S. Stevens, The Cambridge Crystallographic Data Centre#########################################################################################################################"""    2020_Sarah-Unusual_Torsions.py    Classifies torsion angles as usual/unusual using the adjust and change criteria    Associated publication:    Wright, S. E.; Bryant, M. J.; Cruz-Cabeza, A. J.    Is It Usual to Be Unusual? An Investigation into Molecular Conformations in Organic Crystals.    CrystEngComm 2020, 22 (43), 7217â€“7228. https://doi.org/10.1039/C9CE02001B    Requirements / information:    - Mogul geometry analysis settings for torsion angles: organics only    - at least 150 hits in a Mogul torsion histogram for data to be meaningfully fitted (with Kernal Ridge Regression),      after the extra cyclicity and intramolecular hydrogen bond filters are applied    - per rotatable bond, the torsion with the largest number of CSD hits subsequently is retained      on the assumption that distribution with more hits statistically more significant      (if > 1 torsion with same number of hits, then 'Usual' classification given precedence over 'Unusual')    - NOTE: torsion angles involving triple bonds (e.g. cyano) are ignored as always circa linear            and double bonds are not rotatable so not analysed, although both show up in Mogul via Mercury    Input:    - gcd or mol2/multi-mol2 file    - NOTE: cif files should not be used as the script does not apply bond typing    Output:    - png image of retained torsion angle per rotatable bond    - csv with details and torsion classification per rotatable bond (using torsion angle with highest number of hits)    To run this file:    - change line 91 to desired input filepath    - activate the CSD Python API    - run the script as follows:      python 2020_Sarah-Unusual_Torsions.py    NOTE: if using CSD 2023.3 or earlier, a newer version of scikit-learn may be required than in the CSD python API          (sklearn is used for Kernel Ridge Regression)          Either          - update scikit-learn for your python environment (pip install scikit-learn)          or          - alter _ridge.py to replace deprecated syn_pos=True with assume_a='pos' (file is located in e.g.          C:\Program Files\CCDC\ccdc-software\csd-python-api\miniconda\Lib\site-packages\sklearn\linear_model)    ####################################################################################################################    Further info:    - Two conformations are related by adjustment if both originate from the same gas-phase conformer      and they are related by change if they originate from different gas-phase conformers.    - Padjust is total number of exp. observations in histogram bin containing the observed torsion value      divided by the total number of observations in the peak containing the observed value.    - Pchange is total number of hits in peak containing observed torsion over total number of hits in the maximum peak      (if the observed peak the maximum peak, Pchange = 1).    - The smaller the adjustment value becomes, the more significant adjustment becomes.      The smaller change value becomes, the more significant change becomes.    - A torsion is classified as unusual according to adjustment if Padjust is less than 0.05 (5%),      and classified as unusual according to change if Pchange is less than 0.5 (50%),      or if torsion has Padjust < 0.05 and Pchange < 0.5 the torsion is classified as unusual adjustment and change"""########################################################################################################################import matplotlib as mplmpl.use('Agg')							#UNCOMMENT THIS LINE IF WORKING ON THE CSFimport matplotlib.pyplot as pltimport sysfrom ccdc.io import MoleculeReaderfrom ccdc import conformer,moleculeimport numpy as npfrom sklearn.kernel_ridge import KernelRidge  # scikit-learn needs to be more updated version than comes with CSD 2023.3from sklearn.model_selection import GridSearchCVfrom sklearn.gaussian_process.kernels import ExpSineSquaredoutput = open('output.csv', 'w')output.write('Refcode' + ',' + 'R Bond' + ',' + 'Fragment' + ',' + 'Value' + ',' + 'Hits' + ',' +			 'Padjust' + ',' + 'Pchange' + ',' + 'Classification' + ',' + 'Comments' + '\n')headings = ['Fragment', 'Value', 'Hits', 'Padjust', 'Pchange', 'Classification', 'Comment']								   #filepath = sys.argv[1]filepath = 'test.gcd'reader = MoleculeReader(filepath)fig, ax = plt.subplots()criterion = molecule.Molecule.HBondCriterion()  # Set Intramolecular Hydrogen Bond Criteriacriterion.intermolecular = 'intramolecular'criterion.path_length_range = (-1, 999)criterion.angle_tolerance = 120.0criterion.vdw_corrected = Falsecriterion.distance_range = (0, 2.8)criterion.require_hydrogens = Truedef geometry_analyser():	# Sets up setting for Geometry Analyser	engine = conformer.GeometryAnalyser()	engine.settings.bond.analyse = False	engine.settings.angle.analyse = False	engine.settings.torsion.analyse = True	engine.settings.ring.analyse = False	engine.settings.organometallic_filter = 'organics_only'	return engineengine = geometry_analyser()def hit_check(hits):  # Checking if hits are rotatable or affected by intramolecular hydrogen bonding	h_bond = []	rot = []	for hit in hits:		try:			hitmol = hit.molecule			toratoms = hit.atom_labels			bond = hitmol.bond(toratoms[1], toratoms[2])  # Corrected to hitmol instead of mol, as typo meant it threw away hits			if bond.is_rotatable:				rot.append(hit.value)				h_bonds = hitmol.hbonds(hbond_criterion=criterion)				if len(h_bonds) > 0:					for hb in h_bonds:						path = hitmol.shortest_path_bonds(hb.atoms[0], hb.atoms[2])						if bond in path:							h_bond.append(hit.value)  # Values of hits constrained by intra Hbond							break		except:			continue	return rot, h_bonddef unusual_check(bond_dict):  # Take least unusual distribution of the highest hit torsions for a rotatable bond	bond_dict_filtered = {}	obs_classifications = [bond_dict[k]['Classification'] for k, v in list(bond_dict.items()) if 'Classification' in v]	# Taking the least unusual classification	for fragment in bond_dict:		if 'Classification' in bond_dict[fragment]:			if bond_dict[fragment]['Classification'] == 'Usual':				bond_dict_filtered[fragment] = bond_dict[fragment]			elif bond_dict[fragment]['Classification'] == 'Unusual Adjustment' and 'Usual' not in obs_classifications:				bond_dict_filtered[fragment] = bond_dict[fragment]			elif bond_dict[fragment]['Classification'] == 'Unusual Change' and ['Usual', 'Unusual Adjustment'] not in obs_classifications:				bond_dict_filtered[fragment] = bond_dict[fragment]			elif bond_dict[fragment]['Classification'] == 'Unusual Both' and ['Usual', 'Unusual Adjustment', 'Unusual Change'] not in obs_classifications:				bond_dict_filtered[fragment] = bond_dict[fragment]	# Taking the hightest Pchange or Padjust of that classification	final_dict = {}	if len(bond_dict_filtered) == 1:		final_dict = {'Fragment': fragment}		final_dict.update(bond_dict_filtered[fragment])	if len(bond_dict_filtered) > 1:		for fragment in bond_dict_filtered:			if final_dict == {}:				final_dict = {'Fragment': fragment}				final_dict.update(bond_dict_filtered[fragment])			if bond_dict_filtered[fragment]['Pchange'] > final_dict['Pchange']:				final_dict = {}				final_dict = {'Fragment': fragment}				final_dict.update(bond_dict_filtered[fragment])			if bond_dict_filtered[fragment]['Padjust'] > final_dict['Padjust'] and bond_dict_filtered[fragment]['Pchange'] <= final_dict['Pchange']:				final_dict = {}				final_dict = {'Fragment': fragment}				final_dict.update(bond_dict_filtered[fragment])					return final_dictdef find_bond_torsions(bond):	bond_torsions = {}	if len(bond.atoms[0].neighbours) > 1 and len(bond.atoms[1].neighbours) > 1:		for i in range(len(bond.atoms[0].neighbours)):			if bond.atoms[0].neighbours[i] not in bond.atoms:				for j in range(len(bond.atoms[1].neighbours)):					if bond.atoms[1].neighbours[j] not in bond.atoms and bond.is_rotatable:						tor_atoms = [bond.atoms[0].neighbours[i],									 bond.atoms[0],									 bond.atoms[1],									 bond.atoms[1].neighbours[j]]						tor_bonds = (mol.bond(tor_atoms[i].label,tor_atoms[i+1].label) for i in range(len(tor_atoms)-1))						print(tor_atoms)						if all(atom.atomic_number != 1 for atom in tor_atoms) == True and \							all(bond.bond_type != 'Triple' for bond in tor_bonds) == True:							tor = engine.analyse_torsion(*tor_atoms)							if tor.nhits > 150 and tor.value != None:								if bond_torsions == {}:									bond_torsions = {tor.fragment_label : tor.nhits}								maxhits = max([v for k, v in list(bond_torsions.items())])								if tor.nhits > maxhits:  # corrected from >> to > as paper says kept torsion definition affording largest number of CSD hits									bond_torsions = {k: v for k, v in list(bond_torsions.items()) if v != maxhits}									bond_torsions = {tor.fragment_label: tor.nhits}								elif tor.nhits == maxhits:									bond_torsions = {tor.fragment_label: tor.nhits}	return bond_torsionsdef fit_function(histogram):	# This fits a non-periodic function to best find the peak positions	regressor = KernelRidge(alpha=4, gamma=0.004, kernel='rbf', kernel_params=None)	X = np.array([(bin_size/2 + (bin_size * n)) for n in range(len(histogram))]).reshape(-1, 1)	regression = regressor.fit(X, histogram)	return regressionclass circle():	# This is a class of angle that loops around itself	def __init__(self, lst):		self.data = lst		self.extent = len(lst)		self.index = 0	def state_index(self, n):		self.index = n % self.extent	def recall(self, n):		return self.data[n % self.extent]	def idx(self, x):		self.index = x % self.extent		return self.recall(self.index)	def prev(self):		self.index -= 1		return self.recall(self.index)	def nxt(self):		self.index += 1		return self.recall(self.index)	def cur(self):		return self.recall((self.index))def assign_distribution(peak):	peak += 360	left_limit = None	right_limit = None	angs = list(np.arange(360))	#left limit	# to find trough we count backwards from the peak to look for an instance where it rises again	for n in angs:		n = (peak-10) - n		if regression.predict([[n]]) < regression.predict([[n-1]]):			left_limit = n			break	#right limit	# to find trough we count forwards from the peak to look for an instance where it rises again	for n in angs:		n = (peak+10) + n		if regression.predict([[n]]) < regression.predict([[n+1]]):			right_limit = n			break	return left_limit, right_limitdef half_height(peak, ll, rl):	height = regression.predict([[peak]])	hh = height[0]/2  # Changed so only 1st element of array taken in order to work for CSD 2023.3	hll = [x[0] for x in sorted([[angle, abs(regression.predict([[angle]]) - hh)] for angle in range(ll, peak, 1)], key=lambda x: x[1])][0]	hrl = [x[0] for x in sorted([[angle, abs(regression.predict([[angle]]) - hh)] for angle in range(peak, rl, 1)], key=lambda x: x[1])][0]	return hll, hrl, hhfor mol in reader:	print("----------------", str(mol.identifier), "---------------")	# Find unique torsions	struct_dict = {}	for bond in mol.bonds:				# Find rotatable bonds with torsion defined and enough hits		bond_dict = {}		bond_label = str(bond.atoms[0].label) + '-' + str(bond.atoms[1].label)		bond_torsions = find_bond_torsions(bond)		if bond_torsions != {}:			print("----------------- " + str(bond_label) + " -----------------")			print(bond_torsions)			query = False			if len(mol.hbonds(hbond_criterion=criterion)) > 0:				for hb in mol.hbonds(hbond_criterion=criterion):					path = mol.shortest_path_bonds(hb.atoms[0], hb.atoms[2])					if bond in path:						query = True						break			print('Intra H-bond: {}'.format(query))						for fragment_label in bond_torsions:				plt.clf()				fragment = fragment_label.split("_")				fragment = [mol.atom(x) for x in fragment]				torsion = engine.analyse_torsion(*fragment)  # Analysing the torsion fragment				bin_size = 5.0				peaks = []				true_peaks = []				true_peak_data = {}				comment = ''				# First we generate the histogram between 0 and 180 degrees as with Mogul				hist1 = np.array(torsion.histogram(bin_size, 0, 180))  # Original distribution including macrocycles				# Corrected histograms for rotatable bonds and intramolecular hydrogen bonds respectively				rbonds, hbonds = hit_check(torsion.hits)				hist2 = np.histogram(rbonds, bins=36, range=(0,180))[0]  # Excluding Macrocycles				hist3 = np.histogram(hbonds, bins=36, range=(0,180))[0]  # Constrained by Intramolecular Hydrogen Bond				# Use final distribution - corrected for rotatable bonds and hydrogen bonds				if query == True:					hist = np.histogram(hbonds, bins=36, range=(0, 180))[0]				elif query == False:					hist = [hist2[i] - hist3[i] for i in range(len(hist1))]  # If query is not constrained by a hydrogen bond remove these hits from distribution.				tor_hits = int(sum(hist))  # Hits in filtered distribution				title = str(mol.identifier) + " " + str(torsion.fragment_label) + " Total Hits: " + str(tor_hits)				#print title				value = round(torsion.value, 2)				# Mogul assumes symmetry in the torsion, so to expand to 360 we need to mirror the distribution				Y2 = np.concatenate((hist, np.flip(hist, 0)))				hist = np.concatenate((Y2, Y2))				# This is repeated to help with the determination of the periodicity				Y2 = np.concatenate((hist, np.flip(hist, 0)))				hist = np.concatenate((Y2, Y2))				plot_height = max(hist)				X = [(2.5 +(5 * n)) for n in range(len(hist))]  # This is the x-values for the histogram bars				plt.bar(X, hist, bin_size, edgecolor='black', linewidth=1, color='#00FF00')  # This generates the histogram plot				#################### ANALYSIS ######################################################################################				period = 360.00				# Next we need to find a function that fits the distribution well				regression = fit_function(hist)				# In order to plot the function Y = var(x) we generate an array of x values, calculate y and plot as a line				x_values = np.linspace(0, 5*len(hist), 1000).reshape(-1, 1)				Y_new = regression.predict(x_values)				angles = np.arange(360, 720).reshape(-1, 1)				max_peak = regression.predict(angles).max()				# Now we need to pick out the unique peaks				angles = list(np.arange(360, 720))				c_angles = circle(angles)				# to find "turning points" we look for angles where value either side are lower				for x in angles:					c_angles.state_index(x)					ya = regression.predict([[c_angles.prev()]])					yb = regression.predict([[c_angles.idx(x)]])					yc = regression.predict([[c_angles.nxt()]])					if yb > ya and yb > yc and yb > max_peak/100:						peaks.append(x-360)						ry = yb				# The true peaks in the periodic distribution are assigned				for peak in peaks:					if peak < 181:						if peak < period and abs(period - peak) > 15 :							true_peaks.append([peak, regression.predict([[peak]])])				print('Number of true peaks in the distribution: {}'.format(len(true_peaks)))				print('Position of true peaks in the distribution: {}'.format(' '.join(str(peak[0]) for peak in true_peaks)))				for peak in true_peaks:					# We can add additional data to the peaks					x = peak[0]					left_limit, right_limit = assign_distribution(x)					left_bin = int(left_limit/bin_size)					right_bin = int(right_limit/bin_size)					if left_bin < (360/bin_size):						left_bin = int(360/bin_size)					if right_bin > (540/bin_size):						right_bin = int(540/bin_size)					peak_hits = sum([hist[bin] for bin in range(left_bin,right_bin)])					left_half_height, right_half_height, h_height = half_height(peak[0]+360, left_limit, right_limit)					# plot centre of peak					plt.plot([x+360, x+360], [0, regression.predict([[x+360]])[0]], c='red', linewidth=2)					# plot half height					plt.arrow(left_half_height, h_height, (right_half_height-left_half_height), 0, color='red')					# plot peak width					if left_limit < 360:						plt.annotate("",									xy=(360, plot_height*0.1), xycoords='data',									xytext=(right_limit, plot_height*0.1), textcoords='data',									arrowprops=dict(arrowstyle="<-", color='blue'),									)					elif right_limit > 540:						plt.annotate("",									xy=(left_limit, plot_height*0.1), xycoords='data',									xytext=(540, plot_height*0.1), textcoords='data',									arrowprops=dict(arrowstyle="->", color='blue'),									)					else:						plt.annotate("",									xy=(left_limit, plot_height*0.1), xycoords='data',									xytext=(right_limit, plot_height*0.1), textcoords='data',									arrowprops=dict(arrowstyle="<->", color='blue'),									)					# add data about peak to dictionary					true_peak_data[x+360] = {'height': regression.predict([[x+360]])[0],											 'peak_hits': peak_hits,											 'full_width': right_limit-left_limit,											 'angles': [left_limit, right_limit],											 'width at half height': right_half_height - left_half_height,											 'half height limits': [left_half_height, right_half_height]}				tor = abs(torsion.value) + 360 # This is the value of the torsion in the molecule				TorExp = abs(torsion.value)				# This is the distribution we find our torsion in				#print 'FINDING MAXIMUM IN DISTRIBUTION'				TorMaxRegion = max([peak for peak in true_peak_data], key=lambda y: true_peak_data[y]['peak_hits'])				True_TorMaxRegion = TorMaxRegion -360				NTorMax = true_peak_data[TorMaxRegion]['peak_hits']				#print 'FINDING OBSERVED TORSION'				TorExp_Region = None				for x in true_peak_data:					if true_peak_data[x]['angles'][0] < tor < true_peak_data[x]['angles'][1]:						TorExp_Region = x				if TorExp_Region is None:					comment = 'Value not in any distinct peak.'					TorExp_Region =  min([x for x in true_peak_data], key=lambda x: abs(tor-x))				#print 'Query value found in peak at: {} degrees'.format(TorExp_Region-360)				NTorExpMax = hist[int(TorExp_Region/bin_size)]				NTorExp_Region = true_peak_data[TorExp_Region]['peak_hits']				NTorExp_Bin = hist[int(TorExp/bin_size)]	 				adjustment = round(abs(TorExp_Region-tor), 1)				change = round(abs(TorExp_Region-TorMaxRegion), 1)				Padjust = round(float(NTorExp_Bin)/NTorExp_Region, 3)				Pchange = round(float(NTorExp_Region)/NTorMax, 3)				# Print output				if tor_hits < 150:					comment = 'too few hits after filtering'				elif min(hist) > (0.3 * max(hist)):					comment = 'No preferential distribution.'				elif len(true_peaks) >= 4:					comment = 'Distribution too complex.'				elif NTorExp_Region == 0:					comment = 'Not enough hits in exp. region.'				# Make Plot				title = str(mol.identifier) + " " + str(torsion.fragment_label) + " Total Hits: " + str(tor_hits)				max_bin = max([x for x in true_peak_data], key=lambda x: true_peak_data[x]['height'])				plot_height = hist[int(max_bin/5.)]				plt.plot([tor, tor], [0, plot_height], c='black', linewidth=2)				plt.plot(x_values, Y_new)				plt.xlim(360, 540)				plt.ylim(0)				plt.title(title)				plt.xlabel(r'Torsion Angle /$^o$')				plt.ylabel('Number of Hits')				plt.xticks(np.arange(360, 540, step=20), np.arange(0,180, step=20))				plt.xticks(np.arange(360, 540, step=20), np.arange(0,180, step=20))				#plt.show()				# Save plot				torsion_name = str(mol.identifier) + '-' + '-'.join(torsion.atom_labels)				file_name = '%s_histogram.png' % torsion_name				plt.savefig(file_name)				plt.clf() # Clear plot				# Assigning classification				if Pchange >= 0.5 and Padjust >= 0.05:					label = 'Usual'				elif Pchange < 0.5 and Padjust < 0.05:					label = 'Unusual Both'				elif Pchange < 0.5 and Padjust >= 0.05:					label = 'Unusual Change'				elif Pchange >= 0.5 and Padjust < 0.05:					label = 'Unusual Adjustment'				bond_dict[str(torsion.fragment_label)] = {'Value': str(value),														  'Hits': str(tor_hits),														  'Padjust': str(Padjust),														  'Pchange': str(Pchange),														  'Classification': str(label),														  'Comment': str(comment)}			# Filter for least unusual fragment within torsion(s) having the highest number of hits			# (if > 1 torsion with same number of hits, 'Usual' classification given precedence over 'Unusual')			if len(bond_torsions) > 1:				bond_dict = unusual_check(bond_dict)			else:				bond_dict = bond_dict[str(torsion.fragment_label)]				bond_dict.update({'Fragment': str(torsion.fragment_label)})							# Print and Write to CSV			if bond_dict['Comment'] != '':				if bond_dict['Comment'] == 'Value not in any distinct peak.':					output.write(str(mol.identifier) + ',' + bond_label + ',' + bond_dict['Fragment'] + ',' + bond_dict['Value'] + ',' + bond_dict['Hits'] + ',' +								 bond_dict['Padjust'] + ',' + bond_dict['Pchange'] + ',' + bond_dict['Classification'] + ',' + bond_dict['Comment'] + '\n')					for header in headings:						if header in bond_dict:							print(header + ": " + bond_dict[header])				else:					output.write(str(mol.identifier) + ',' + bond_label + ',' + bond_dict['Fragment'] + ',' + bond_dict['Value'] + ',' + bond_dict['Hits'] + ',' +								 ',' + ',' + ',' + bond_dict['Comment'] + '\n')					for header in headings:						if header in bond_dict:							print(header + ": " + bond_dict[header])			else:				output.write(str(mol.identifier) + ',' + bond_label + ',' + bond_dict['Fragment'] + ',' + bond_dict['Value'] + ',' + bond_dict['Hits'] + ',' +							 bond_dict['Padjust'] + ',' + bond_dict['Pchange'] + ',' + bond_dict['Classification'] + ',' + bond_dict['Comment'] + '\n')				for header in headings:					print(header + ": " + bond_dict[header])			print("-----------------------------------------")output.close()